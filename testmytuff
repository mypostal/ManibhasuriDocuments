**Architecture Document: Multi-SKU Fair Task Scheduler for Tenant Operations**

---

### 1. **Current Architecture**

The current system processes tenant-related operations such as Create, Update, and Delete by executing a sequence of service API calls or Service Bus messages. Each operation is persisted in an `ExecutionInstance` table, which contains the steps required. These steps are further tracked in the `EventInstance` table.

#### Characteristics:
- Operations are asynchronous.
- Each operation initiates multiple service-specific actions.
- All downstream service calls are triggered concurrently with no throttling.

#### Problems:
- Downstream systems (IAM, IOT, etc.) are overwhelmed under concurrent loads.
- No limit or queuing on service-specific concurrency.
- One Product SKU (e.g., mass updates) can dominate system resources (noisy neighbor problem).

---

### 2. **Problem Statement**

**Objective:**
Introduce a queuing mechanism to:

- Limit concurrent calls per service.
- Enforce fair scheduling across Product SKUs.
- Prioritize Create operations over Update/Delete.
- Avoid concurrent operations for the same tenant-service pair.

---

### 3. **Proposed Architecture**

A centralized background task scheduler picks tasks from a queue, applies fairness rules, and dispatches them to handlers.

#### Key Components:
- **ServiceTaskQueue Table**: Stores task details (Operation, Service, Product SKU, etc.).
- **ServiceTaskScheduler**: Central logic to apply fair scheduling, enforce limits, and assign execution.
- **BackgroundTaskSchedulerService**: Periodically polls the scheduler and executes eligible tasks.
- **Task Handlers (IAM, IOT, etc.)**: Execute service-specific logic.

#### Scheduling Rules:
- No more than `MaxConcurrency` tasks per service.
- Only `PerSkuLimit` pending tasks per SKU are selected.
- Tasks are processed in **round-robin** fashion across SKUs.
- Tasks for a tenant already in `InProgress` are skipped.
- SQL uses `ROW_NUMBER()` for partitioned priority ordering.

---

### 4. **Database Tables**

#### `ServiceTaskQueue`
| Column             | Type         | Description                         |
|--------------------|--------------|-------------------------------------|
| Id                 | GUID         | Unique identifier                   |
| ExecutionInstanceId| GUID         | Refers to the original execution    |
| EventInstanceId    | GUID         | Refers to the specific event step   |
| TenantId           | string       | Unique tenant identifier            |
| ProductSku         | string       | SKU grouping                        |
| ServiceName        | string       | IAM, IOT, etc.                      |
| Operation          | enum         | Create, Update, Delete              |
| Status             | enum         | Pending, InProgress, Completed, Failed |
| InsertedAt         | DateTime     | Timestamp of enqueue                |
| RetryCount         | int          | Retry attempts                      |

---

### 5. **Class and Object Diagrams**

#### Core Classes:
- `ServiceTaskQueue` – entity model.
- `ServiceExecutionOptions` – config model per service.
- `IServiceTaskHandler` – handler contract.
- `ServiceTaskScheduler` – scheduling logic.
- `BackgroundTaskSchedulerService` – orchestrates execution.

#### Relationships:
```
[BackgroundTaskSchedulerService] 
    --> (uses) [ServiceTaskScheduler]
    --> (resolves) [IServiceTaskHandler] via [HandlerType]

[ServiceTaskScheduler] 
    --> (uses) [ProvisioningDbContext] 
    --> (reads/writes) [ServiceTaskQueue]

[IServiceTaskHandler] <|-- IamTaskHandler, IotTaskHandler
```

---

### 6. **Execution Flow Summary**

1. `BackgroundTaskSchedulerService` iterates over configured services.
2. For each, it invokes `GetScheduledTasksAsync(...)`:
   - Applies `ROW_NUMBER()` per SKU
   - Skips if `InProgress >= MaxConcurrency`
   - Skips if tenant is already in progress
3. Eligible tasks are executed via `IServiceTaskHandler`.
4. Task status is updated to `InProgress` → `Completed/Failed`

---

### 7. **Sequence Diagram (PlantUML)**
```plantuml
@startuml
actor Scheduler
entity Database
participant ServiceTaskScheduler
participant TaskHandler

Scheduler -> ServiceTaskScheduler: GetScheduledTasksAsync
ServiceTaskScheduler -> Database: Fetch InProgress count
ServiceTaskScheduler -> Database: Fetch pending tasks using ROW_NUMBER()
ServiceTaskScheduler -> Scheduler: Return tasks

loop for each task
    Scheduler -> TaskHandler: ExecuteAsync(task)
    TaskHandler -> Database: Update Status to InProgress
    TaskHandler -> ExternalService: Call IAM/IOT API
    TaskHandler -> Database: Update Status to Completed/Failed
end
@enduml
```

---

### 8. **Visual Data Flow Diagram**
```text
+------------------+           +---------------------+          +-------------------+
| Tenant Operation |  ---->    | ServiceTaskQueue DB |  --->    | Background Service |
| (Create/Update)  |           |                     |          | Scheduler          |
+------------------+           +---------------------+          +--------+----------+
                                                                      |
                                                                      v
                                                             +--------+-----------+
                                                             |  ServiceTaskScheduler|
                                                             +--------+-----------+
                                                                      |
                                                                      v
                                                             +--------+-----------+
                                                             | Task Handler (IAM) |
                                                             | Task Handler (IOT) |
                                                             +--------------------+
```

---

### 9. **Observability & Troubleshooting Design**

#### 1. **Structured Logging**
- Log task transitions with Task ID, Tenant ID, SKU, Operation, and Status.
- Include retry attempts and exception messages.

#### 2. **Metrics (Prometheus/Grafana)**
- Number of tasks processed per service/SKU.
- Current queue length.
- Average task duration per service.
- Retry/failure rate.

#### 3. **Health Probes**
- Expose a `/health/tasks` endpoint with:
  - Stuck tasks
  - InProgress older than N mins
  - Failed tasks with retries > threshold

#### 4. **Alerting**
- Alert on high retry count.
- Alert if no tasks processed in X minutes.
- Alert on DB latency or locking issues.

---

### 10. **Example Scenario**

### 10.1 **SKU Starvation Protection Logic (Visual)**

#### Scheduler Decision Table per Round
| Round | Slot 1 (MaxConcurrency 1) | Slot 2 | Slot 3 |
|-------|---------------------------|--------|--------|
| 1     | A-Create1                 | B-Create1 | C-Create1 |
| 2     | A-Create2                 | B-Create2 | C-Create2 |
| 3     | A-Update1                 | B-Update1 | C-Delete1 |
| 4     | A-Update2                 | B-Update2 | C-Delete2 |

Each round respects concurrency and fairness across SKUs.

```text
Round Robin Queue Selection:
+-----------+-----------+-----------+
|  SKU A    |  SKU B    |  SKU C    |
+-----------+-----------+-----------+
| Create 1  | Create 1  | Create 1  |
| Create 2  | Create 2  | Create 2  |
| Update 1  | Update 1  | Delete 1  |
| Update 2  | Update 2  | Delete 2  |
+-----------+-----------+-----------+

Scheduler Logic:
1. Scheduler cycles through SKUs in order.
2. Picks top N (PerSkuLimit) from each SKU using SQL `ROW_NUMBER()`.
3. Distributes work fairly across SKUs by interleaving operations.
4. Ensures high-volume SKU (like A) doesn’t block B or C from progressing.
```

#### Setup:
- Products: A, B, C
- `MaxConcurrency = 3`, `PerSkuLimit = 2`
- Initial Queue:
```
Product A: 5 Create, 10 Update
Product B: 2 Create, 10 Update
Product C: 2 Create, 10 Delete
```

#### Step-by-Step Execution:
1. `ServiceTaskScheduler` applies `ROW_NUMBER()` by SKU and filters top 2 for each.
2. It picks:
   - Product A: 2 Create
   - Product B: 2 Create
   - Product C: 2 Create
3. It runs one task per SKU in a round-robin until `MaxConcurrency` is reached (3):
   - Round 1: A-Create1, B-Create1, C-Create1
   - Round 2: A-Create2, B-Create2, C-Create2
4. Once a task completes, it processes more from same SKU (e.g., A-Update1 if Product A has room).
5. If a tenant is already in progress, that task is skipped in this round.

---

Let me know if you’d like a full deployment diagram or logging schema added.


ChatGPT said:
Perfect — let’s break this down step-by-step using your current scheduling setup, where:

Each product should get fair access to processing slots.

Create has higher priority than Update.

Max concurrency per service (e.g., IAM) is 2.

🎯 Scenario Setup
You have:

Product	Create Tasks	Update Tasks
A	5	10
B	2	10
C	2	10
D	2	10
E	2	10

🧱 Scheduling Strategy Recap
You're using:

ROW_NUMBER() + PARTITION BY ProductSku ORDER BY Operation, InsertedAt

WHERE rn <= 1 → fetch 1 highest-priority task per product

Then apply round-robin or per-SKU fair scheduling

Max 2 concurrent tasks per poll

🧮 SQL Fetch (per service): What gets returned?
From the raw SQL query:

sql
Copy
Edit
SELECT *
FROM (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY ProductSku ORDER BY Operation, InsertedAt) AS rn
  FROM ServiceTaskQueues
  WHERE Status = 0 AND ServiceName = 'IAM'
) sub
WHERE rn <= 1
✅ This returns:

Product A → 1 Create

Product B → 1 Create

Product C → 1 Create

Product D → 1 Create

Product E → 1 Create

⏱️ Round-by-Round Execution (MaxConcurrency = 2)
Round 1
Tasks in memory: A(C1), B(C1), C(C1), D(C1), E(C1)

Round-robin picks: ✅ A(C1), ✅ B(C1)

In-flight: A(C1), B(C1)

Round 2
A and B completed

Next picks: ✅ C(C1), ✅ D(C1)

Round 3
C and D completed

Next picks: ✅ E(C1), ✅ A(C2)

Round 4
E and A completed

Next picks: ✅ A(C3), ✅ B(C2)

Round 5
A and B completed

Next picks: ✅ C(C2), ✅ D(C2)

Round 6
C and D completed

Next picks: ✅ E(C2), ✅ A(C4)

Round 7
E and A completed

Next picks: ✅ A(C5), ✅ B(U1)

From here onward, all Create tasks are done. We begin processing Update tasks based on round-robin fairness.

📊 Summary of Task Flow
Round	A	B	C	D	E
1	✅ C1	✅ C1			
2			✅ C1	✅ C1	
3	✅ C2				✅ C1
4	✅ C3	✅ C2			
5			✅ C2	✅ C2	
6	✅ C4				✅ C2
7	✅ C5	✅ U1			
8	✅ U1	✅ U2			
...	(rotation continues through updates fairly)				

✅ Key Takeaways
Product-A, despite having many Create and Update tasks, does not block others.

All Create operations are processed first, due to operation priority.

Once Create tasks finish, Update operations begin across all products — still fair.

ROW_NUMBER() + rn <= 1 ensures each product gets a chance per scheduling round, avoiding starvation.


